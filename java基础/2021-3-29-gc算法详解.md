# 如何判定对象（在堆中的实例）可以被回收

## 引用计数法
* 给对象添加一个引用计数器，有地方引用，就加一，引用失效就减一。
* 这个方法实现简单效率高，但是不能解决因为循环引用造成对象一直不释放的问题， 所以基本没有jvm使用
    
## 可达性分析
* 将一系列称为“GC Roots”的对象作为起点，开始向下搜索，节点走过的路径称为引用链，当一个对象到GC Roots没有任何引用链，则证明此对象不可用
    
### 可作为GC Roots对象包括以下几种  
* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI（Native）引用的对象


### finalize（）方法判定对象存活
* 当没有覆写finalize方法或者finalize方法已经被虚拟机调用过之后，对象将被回收
* 否则将对象放在F-Queue 队列中，稍后由虚拟机自动建立低优先级的finalize线程去执行，如果方法中对象没有被重新引用，则回收

# 判断常量是废弃常量
* 如果当前没有任何对象引用该常量，则说明该常量是废弃常量，会清理出常量池

# 判断无用的类，需要满足三个条件：
* 该类所有实例被回收
* 加载该类的ClassLoader已经被回收
* 类对应的java.lang.Class对象没有任何地方被引用，且无法在任何地方通过反射访问该类的方法


# 垃圾回收算法（GC Garbage Collection）

## 标记清除算法
* 基础收集算法，分两个阶段，**标记和清除**。通过可达性分析，标记完成后回收被标记的对象
* 缺点：效率不高，会产生大量内存碎片，可能导致创建大对象时找不到足够内存，触发GC，造成GC频繁
## 复制算法
* 内存分大小相同的两块，每次只使用一块，用完一块，将存活的对象复制到另一块内存中
* 优点：不用考虑碎片问题，简单高效
* 缺点：内存利用率不高，只用了一半内存
## 标记整理算法
* 标记以后，所有存活对象向一端对齐，然后清理掉边界以外的内存
## 分代算法
* 根据对象存活时间，将内存分为新生代和老年代
* 年轻代一半选用复制算法
* 老年代一般选用标记整理或标记清除



# gc收集器
[image](https://github.com/pp7221343/Interview-preparation/blob/main/img/2020020323310682.png?raw=true)
