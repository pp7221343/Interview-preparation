# 如何判定对象（在堆中的实例）可以被回收

## 引用计数法
* 给对象添加一个引用计数器，有地方引用，就加一，引用失效就减一。
* 这个方法实现简单效率高，但是不能解决因为循环引用造成对象一直不释放的问题， 所以基本没有jvm使用
    
## 可达性分析
* 将一系列称为“GC Roots”的对象作为起点，开始向下搜索，节点走过的路径称为引用链，当一个对象到GC Roots没有任何引用链，则证明此对象不可用
    
### 可作为GC Roots对象包括以下几种  
* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI（Native）引用的对象


### finalize（）方法判定对象存活
* 当没有覆写finalize方法或者finalize方法已经被虚拟机调用过之后，对象将被回收
* 否则将对象放在F-Queue 队列中，稍后由虚拟机自动建立低优先级的finalize线程去执行，如果方法中对象没有被重新引用，则回收

# 判断常量是废弃常量
* 如果当前没有任何对象引用该常量，则说明该常量是废弃常量，会清理出常量池

# 判断无用的类，需要满足三个条件：
* 该类所有实例被回收
* 加载该类的ClassLoader已经被回收
* 类对应的java.lang.Class对象没有任何地方被引用，且无法在任何地方通过反射访问该类的方法


# 垃圾回收算法（GC Garbage Collection）

## 标记清除算法
* 基础收集算法，分两个阶段，**标记和清除**。通过可达性分析，标记完成后回收被标记的对象
* 缺点：效率不高，会产生大量内存碎片，可能导致创建大对象时找不到足够内存，触发GC，造成GC频繁
## 复制算法
* 内存分大小相同的两块，每次只使用一块，用完一块，将存活的对象复制到另一块内存中
* 优点：不用考虑碎片问题，简单高效
* 缺点：内存利用率不高，只用了一半内存
## 标记整理算法
* 标记以后，所有存活对象向一端对齐，然后清理掉边界以外的内存
## 分代算法
* 根据对象存活时间，将内存分为新生代和老年代
* 年轻代一半选用复制算法
* 老年代一般选用标记整理或标记清除



# gc收集器
![image](https://github.com/pp7221343/Interview-preparation/blob/main/img/2020020323310682.png?raw=true)


## Serial收集器
* 基本收集器，串行，**它在进行垃圾收集工作的时候必须暂停其他所有的工作线程 “Stop The World” ，简称STW）**
* 新生代采用复制算法，老年代（需要其他收集器配合）采用标记-整理算法。

## ParNew收集器
* Serial收集器的多线程版本，**也是会暂停其他所有进程（STW）**。
* 新生代采用复制算法，老年代（需要其他收集器配合）采用标记-整理算法。

## Parallel Scavenge收集器
* 并行收集器，类似ParNew，jdk1.8的默认收集器
* 收集器关注点是吞吐量（高效率的利用CPU）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。
* **应用线程仍然处于等待状态（STW）**

## Serial Old收集器
* Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。

## Parallel Old收集器
* Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。

## CMS收集器
* CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。
* CMS收集器是一种 “标记-清除”算法实现的

  ## 运行过程
  * 初始标记（CMS initial mark）： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快。多线程标记。
  * 并发标记（CMS concurrent mark）： 同时开启并发标记线程和用户线程，用一个闭包结构去从GC Root开始对堆中对象进行可达性分析，找出存活的对象可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
  * 重新标记（CMS remark）： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
  * 发清除（CMS concurrent sweep）： 开启用户线程，同时GC线程开始对为标记的区域做清扫。在这个期间就会产生浮动垃圾，就是在并发清理期间用户线程执行期间还是有可能产生垃圾，这些垃圾在本次GC中是不能被回收的，这些垃圾就是浮动垃圾。浮动垃圾只能等到下次GC被清除。
  * 并发重置：准备进行下一次GC

**CMS收集器开启后，年轻代使用STW式的并行收集（ParNew收集器），老年代回收采用CMS进行垃圾回收**

优点：并发收集、低停顿。
缺点有三：对CPU资源敏感；无法处理浮动垃圾；它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

  ###为什么除了Serial收集器外只有ParNew能与CMS收集器配合？
 * CMS是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；CMS作为老年代收集器，但却无法与JDK1.4已经存在的新生代收集器Parallel Scavenge配合工作；因为Parallel Scavenge（以及G1）都没有使用传统的GC收集器代码框架，而另外独立实现；而其余几种收集器则共用了部分的传统框架代码，所以除了Serial收集器外，只有ParNew能与CMS收集器配合。


## G1收集器

* G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1收集器在jdk1.9后成为了JVM的默认垃圾收集器。

### 分区和卡片的关系
#### 分区Region
* G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。
* Humongous区是大对象存放的区域，在之前的收集器都有分匹配担保机制，在新生代的大对象如果存放不了就会被装入老年代，但是G1收集器中大对象会被直接放到Humongous区。G1内部做了一个优化，一旦发现没有引用指向大对象，则可直接在年轻代收集周期中被回收。

#### 卡片Card
* 在每个分区内部又被分成了若干个大小为512 Byte卡片(Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象。每次对内存的回收，都是对指定分区的卡片进行处理。


参考博客：https://blog.csdn.net/cy973071263/article/details/104163611
